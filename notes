DEFINITION

- processus = programme en cours d'execution

- serveur = processus dont le role est de repondre aux requetes envoyees par des clients via un reseau

- serveur demon = programme tournant en arriere plan et gerant les donnees

- Image = packqge contenant du code, des statiaqes, des dependances, le tout inactif

- Conteneur = activation d'une image de facon a faire tourner un processus

- paquet (ou package) = fichier ou ensemble de fichiers contenant un logiciel ou une bibliothèque prête à être installée et permettant son installation; il inclut aussi des informations pour le gestionnaire de paquets (ici apt) comme la version, les dependeances, les scripts d'installation

- dependance = logiciel, bibliotheque ou outil dont un autre programme a besoin pour fonctionner correctement


- interface ligne de commande (CLI) = interface basee sur du texte dans laquelle on peut saisir des commandes qui interagissent avec le systeme d'exploitation d'un ordinateur

- docker-compose = fichier servant a decrire une application  multi-conteneurs dans  un fichier texte puis de la lancer
avantages = -- regrouper plusieurs conteneurs en un projet
-- gerer automatiquement le reseau (cree automatiquement)
-- gerer les volumes
-- definir les dependances (ie ordre de demarrage logique des conteneurs)
-- lancer et arreter toute l'application en une seule commande (docker-compose up et docker-compose down)

COMMANDES (en minuscule, a preceder de 'docker'):
- BUILD = docker build (-t nginx) srcs/requirements/nginx
  -t nginx : sert a donner un nom specifique a l'image creee

- RUN = docker run nginx
  -it : sert a ouvrir le terminal du conteneur a son lancement
  -d : detach, pour que le conteneur tourne en arriere plan
  --name <nom> : nommer le process du conteneur pour qu'il soit plus facile a retrouver

- EXEC = run <container_id (or name)> + commande
  => executer une commande a l'interieur du conteneur
  -it : i -> interactif (garde l'entree standard ouverte)
    t -> tty (simule un terminal)

- BUILD et RUN du fichier .yaml
docker compose up -d --build

- BUIL yaml
docker compose build

- RUN le yaml
docker compose up

- ARRETER le YAML
docker compose stop

- REDEMARRER le YAML
docker compose start

- SUPPRIMER le YAML (build)
docker compose down (supprime conteneur et reseaux)
docker compose down -v  (supprime aussi les volumes)


Fonctionnement de TLS:
la commande openssl req -x509 -nodes -out /etc/nginx/ssl/inception.crt -keyout /etc/nginx/ssl/inception.key -subj "/C=FR/ST=IDF/L=Paris/O=42/OU=42/CN=login.42.fr/UID=login"
permet de demander un certificat SSL (le certficat est stocke dans out et la cle dans keyout)
1) certificat = carte d'identite
role = prouver que le site est celui qu'il pretend etre
ce qu'il contient = nom de domaine (ex: erika.42.fr), nom de l'autorité qui l'a signé, et clé publique
2) cle privee = clef du coffre (secret)
role = dechifrer les donnees que les clients ont envoyees en utilisant la clef publique
securite = Si quelqu'un vole ta clé privée, il peut usurper ton identité et lire les messages cryptés destinés à ton serveur

Comment ça marche lors d’une connexion HTTPS ?
1. Le client demande une connexion sécurisée à nginx.
2. Nginx envoie son certificat (contenant la clé publique) au client.
3. Le client vérifie que le certificat est valide (date, signature de l’autorité, correspondance du nom de domaine).
4. Le client crée une clé de session (clé symétrique temporaire) et la chiffre avec la clé publique du serveur (dans le certificat).
5. Le serveur (nginx) déchiffre la clé de session avec sa clé privée.
6. Maintenant, client et serveur ont une clé symétrique partagée pour chiffrer toute la communication rapidement.
7. Toute la communication est sécurisée grâce à cette clé symétrique.

Pourquoi creer un fichier /var/run/nginx ?
Ce dossier sert à stocker ce qu'on appelle un PID file (Process ID).
-Le concept : Quand Nginx se lance, il écrit son numéro d'identité (le PID) dans un petit fichier à cet endroit précis.
Cela permet au système de savoir si Nginx est déjà en train de tourner et de pouvoir l'arrêter proprement.
-Le problème Docker : Dans certaines versions de Debian/Alpine (les images de base que tu utilises pour Docker), ce dossier n'existe pas par défaut ou n'a pas les bonnes permissions.
Si Nginx essaie de se lancer et ne trouve pas ce dossier pour y écrire son PID, il va crash instantanément avec une erreur.
=> il s'agit de modifier les dossiers systeme a l'interieur du conteneur

Filesystem Hierarcy Standard (FHS); dossiers:
-  /usr/local/bin = executables installes par l'utilisateur (localise ici ils sont appelable partout)
- /etc = fichiers de configuration statique (c'est ici que les logiciels comme php ou nginx cont chercher leurs reglagles au demarrage)
- /var/www = dossier standard de stockage des donnees variables (ie qui changent pendant l'execution) de serveur web
--/var/lib : données persistantes propres à un service
--/var/www : convetion Lunix pour les fichiers web
- /tmp = dossier destine aux fichiers temporaires (comme les script de config qui servent a configurer des conteneurs au demarrage, avant que le site ne tourne)
- /run = runtime data; contient les données valides uniquement depuis le dernier démarrage. Ce dossier est vidé automatiquement à chaque redémarrage du PC/Conteneur.

Autres DEFINITIONS UTILES
- code source = texte lisible par l'humain ecrit par les programmeurs


DNS (Domain Name System ou systeme de nom de domaine)
C'est un système de traduction indispensable dans un réseau informatique.

- Le problème : Les ordinateurs ne communiquent qu'avec des adresses IP (ex : 192.168.1.15). Mais les humains (et les configurations logicielles) préfèrent utiliser des noms (ex : google.com ou mariadb)

- La solution (DNS) : C'est un annuaire automatique. Quand tu tapes google.com, le serveur DNS cherche dans sa liste et répond à ton ordinateur : "L'adresse IP de https://www.google.com/url?sa=E&source=gmail&q=google.com est 142.250.75.100". Ton ordinateur se connecte alors à cette IP.

Dans Inception, Docker possède son propre DNS interne.





#Code source de Wordpress#

Lors de l'installation de Wordpress, on telecharge un dossier rempli de fichiers textes, ce n'est pas un seul bloc (comme un .exe). C'est une collection de fichiers qui travaillent ensemble.

#HTML (structure, squelette)
Ce n'est pas un langage de programmation, c'est du balisage. Il dit au navigateur "Ceci est un titre", "Ceci est une image".
ex:
      <h1>Bienvenue sur mon site</h1>
      <p>Ceci est un paragraphe de texte.</p>

#CSS (style, habillage)
Ce sont des fichiers (extension .css) qui disent au navigateur comment afficher le HTML. Ex:
  h1 {
      color: red;
      font-size: 20px;
  }

#PHP (la logique, le cerveau)
C'est un programme qui ecrit du html
Ex : <?php
  // 1. LOGIQUE (PHP) : On définit des variables (ou on les cherche dans MariaDB)
  $nom_utilisateur = "Erika";
  $couleur_titre = "blue";
?>

<html>
  <head>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1 style="color: <?php echo $couleur_titre; ?>;">
      Bienvenue <?php echo $nom_utilisateur; ?> !
    </h1>
  </body>
</html>

Quand tu demandes cette page :
Nginx voit l'extension .php. Il ne l'envoie pas au navigateur. Il le passe à PHP-FPM.
PHP-FPM lit le fichier de haut en bas.
Il exécute les instructions entre <?php ... ?>.
Il remplace <?php echo $nom_utilisateur; ?> par "Erika".
Il remplace <?php echo $couleur_titre; ?> par "blue".
Il supprime toutes les balises PHP du résultat final.
Code source reçu (HTML) :
<html>
  <head>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1 style="color: blue;">
      Bienvenue Erika !
    </h1>
  </body>
</html>


Particularite du PHP : Contrairement au C++ que tu dois compiler (transformer en a.out illisible) pour qu'il fonctionne, le PHP est un langage interprété. Cela signifie que le "code source" (les fichiers textes) EST le programme final.
- Langage COMPILE = Le compilateur traduit tout le code d'un coup en langage machine (des 0 et des 1), c'est la compilation, et on oibtient un fichier binaire executable. Avantage = rapidite; inconvenient = recompilation necessaire pour une seul ligne changee
VS
- langage INTERPRETE = Ecriture en code comprehensible puis execution : Quand tu lances le programme, un logiciel appelé l'interpréteur (ex: le programme python ou php-fpm) lit ton fichier ligne par ligne. Le code source EST le programme. Avantage : Flexible. Tu modifies le fichier texte, tu sauvegardes, et la modification est immédiate (pas de make re); Inconvénient : Plus lent

# Pourquoi a-t-on besoin de plusieurs processus pour faire tourner wordpress ? #
Parce qu'un processus PHP-FPM (appelé "Worker" ou travailleur) ne peut traiter qu'une seule requête HTTP à la fois
Dans l'architecture de PHP-FPM, il y a deux types de processus :
- Le processus Maître (Master Process) : Il ne traite jamais les requêtes web. Son unique travail est de surveiller le réseau et de gérer la RAM.
- Les processus Enfants (Child Processes / Workers) : ils exécutent le code WordPress.


# Fonctionnement de Socket Unix #
Il s'agit d'un mécanisme de communication inter-processus (IPC) géré par le noyau Linux.
Elle permet à deux programmes s'exécutant sur la même machine d'échanger des données
- Dans le système de fichiers, elle se présente sous la forme d'un fichier avec une extension .sock.
- Contrairement à un fichier texte standard, aucune donnée n'est écrite sur le disque dur physique.
Lorsque Nginx tente "d'écrire" dans ce fichier .sock :
1) Le processus de destination (PHP-FPM) demande au noyau Linux dede créer l'entrée /run/php/php8.2-fpm.sock dans le système de fichiers, en spécifiant que cette entrée est une socket liée à son propre processus.
2) Nginx veut envoyer une requête web. Il demande au noyau Linux d'ouvrir le fichier /run/php/php8.2-fpm.sock pour y écrire des données.
3) L'interception : Le noyau Linux voit que le type de ce fichier est une socket. Au lieu de transmettre les données au disque dur, le noyau intercepte les données.
4) Le transfert en RAM : Le noyau Linux prend les données depuis la mémoire vive (RAM) allouée à Nginx, et les injecte directement dans la mémoire vive (RAM) allouée à PHP-FPM


# Les differents mode de reseaux #

1) Mode bridge (par defaut dans Docker)
Chaque conteneur reçoit une adresse IP privée dans un sous-réseau spécifique
Les conteneurs sont isolés du réseau physique de la VM. Pour qu'un service soit accessible depuis l'extérieur de la VM (ou depuis la VM elle-même), il faut effectuer un mappage de ports (ex: -p 80:80).
Communication :
- Bridge par défaut : Les conteneurs communiquent via leurs adresses IP uniquement.
- User-defined Bridge (celui d'Inception) : Docker active un résolveur DNS interne. Cela permet à wordpress de contacter mariadb en utilisant le nom du service, sans connaître son IP.

2) Mode host
Ce mode supprime l'isolation réseau entre le conteneur et la VM
Le conteneur n'a pas sa propre adresse IP. Il utilise directement l'adresse IP de la VM.
Pas de translation de port (NAT)
Rapide car pas de surcharge lie a la virtualisation reseau mais moins securise et flexible

3) Mode None
= Aucune connectivité réseau du conteneur.
Le conteneur possède une interface de boucle locale (lo / 127.0.0.1), mais aucune interface réseau externe (pas de eth0).
Utile pour des conteneurs qui effectuent des calculs isolés ou des tâches de traitement de fichiers ne nécessitant aucun accès réseau (sécurité maximale).

4) Mode Overlay
Ce mode est utilisé pour la communication entre conteneurs situés sur des hôtes (VM) différents.
Il crée un réseau virtuel au-dessus des réseaux des hôtes physiques.

5) Le mode Macvlan
Ce mode permet de donner une adresse MAC directement au conteneur.
Le conteneur apparaît comme un équipement physique réel sur le réseau local de la box ou du routeur, comme la VM elle-même.
Usage : Très spécifique, utilisé quand des applications héritées (legacy) ont besoin d'être connectées directement au réseau physique sans passer par le NAT de Docker.
