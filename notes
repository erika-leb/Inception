# DEFINITION #

- processus = programme en cours d'execution

- serveur = processus dont le role est de repondre aux requetes envoyees par des clients via un reseau

- serveur demon = programme tournant en arriere plan et gerant les donnees

- Image = packqge contenant du code, des statiaqes, des dependances, le tout inactif

- Conteneur = activation d'une image de facon a faire tourner un processus

- paquet (ou package) = fichier ou ensemble de fichiers contenant un logiciel ou une bibliothèque prête à être installée et permettant son installation; il inclut aussi des informations pour le gestionnaire de paquets (ici apt) comme la version, les dependeances, les scripts d'installation

- dependance = logiciel, bibliotheque ou outil dont un autre programme a besoin pour fonctionner correctement


- interface ligne de commande (CLI) = interface basee sur du texte dans laquelle on peut saisir des commandes qui interagissent avec le systeme d'exploitation d'un ordinateur

- docker-compose = fichier servant a decrire une application  multi-conteneurs dans  un fichier texte puis de la lancer
avantages = -- regrouper plusieurs conteneurs en un projet
-- gerer automatiquement le reseau (cree automatiquement)
-- gerer les volumes
-- definir les dependances (ie ordre de demarrage logique des conteneurs)
-- lancer et arreter toute l'application en une seule commande (docker-compose up et docker-compose down)

# Differences entre Build et RUN #
- Phase de BUILD
= tout ce qui est statique
L'image doit être immuable (elle ne change plus une fois créée) et réutilisable.
On y place les actions lourdes qui n'ont pas besoin de connaître la configuration finale pour s'exécuter :
    *L'installation des paquets système : RUN apt-get install nginx mariadb-server -y.
    *La copie des fichiers figés : COPY conf/nginx.conf /etc/nginx/nginx.conf.
    *La création de l'arborescence de base : RUN mkdir -p /var/run/nginx.
    *Le téléchargement des sources : Récupérer l'archive de WordPress avec wget et l'extraire.
- Phase de RUN
= tout de qui dynamique et constextuel
Le script (souvent défini comme ENTRYPOINT) s'exécute au démarrage du conteneur. on gere alors  l'état, les variables, et les éléments extérieurs (comme les volumes):
    * L'utilisation des variables d'environnement (.env) 
    Le Dockerfile ne doit pas contenir tes mots de passe ou noms de domaine en dur (pour des raisons de sécurité). 
    * L'initialisation des bases de données 
    les volumes ne sont montés et accessibles qu'au moment du Run. Si on initialise la base de données dans le Dockerfile, les données seront écrasées par le volume au lancement.
    * Les ajustements de permissions sur les volumes 
    Docker monte souvent les volumes persistants avec les droits de l'utilisateur root. Le script doit faire un chown au démarrage pour donner les droits corrects à l'utilisateur du service.
    * La vérification de l'état (Idempotence) 
    Le script vérifie si la configuration est déjà faite grâce aux redémarrages précédents 

"Si je donne cette image à un autre étudiant avec un fichier .env différent, cette action exacte doit-elle être modifiée ?"
Non (ex: installer le paquet PHP) -> Dockerfile.
Oui (ex: créer un utilisateur spécifique dans la base de données) -> Script

# differences enter Dockerfile et docker-compose
- Dockerfile : cript de compilation. Il genere une image, sorte d'executable.
Une fois le docker build terminé, l'image est un objet immuable.
- Docker compose : fichier de configuration déclaratif
Son rôle n'est pas de construire le système de fichiers, mais de définir les règles selon lesquelles le démon Docker doit instancier et exécuter ces images sous forme de conteneurs.

# COMMANDES # (en minuscule, a preceder de 'docker'):
- BUILD = docker build (-t nginx) srcs/requirements/nginx
  -t nginx : sert a donner un nom specifique a l'image creee

- RUN = docker run nginx
  -it : sert a ouvrir le terminal du conteneur a son lancement
  -d : detach, pour que le conteneur tourne en arriere plan
  --name <nom> : nommer le process du conteneur pour qu'il soit plus facile a retrouver

- EXEC = run <container_id (or name)> + commande
  => executer une commande a l'interieur du conteneur
  -it : i -> interactif (garde l'entree standard ouverte)
    t -> tty (simule un terminal)

- BUILD et RUN du fichier .yaml
docker compose up -d --build

- BUIL yaml
docker compose build

- RUN le yaml
docker compose up

- ARRETER le YAML
docker compose stop

- REDEMARRER le YAML
docker compose start

- SUPPRIMER le YAML (build)
docker compose down (supprime conteneur et reseaux)
docker compose down -v  (supprime aussi les volumes)


# Fonctionnement de TLS: #
la commande openssl req -x509 -nodes -out /etc/nginx/ssl/inception.crt -keyout /etc/nginx/ssl/inception.key -subj "/C=FR/ST=IDF/L=Paris/O=42/OU=42/CN=login.42.fr/UID=login"
permet de demander un certificat SSL (le certficat est stocke dans out et la cle dans keyout)
1) certificat = carte d'identite
role = prouver que le site est celui qu'il pretend etre
ce qu'il contient = nom de domaine (ex: erika.42.fr), nom de l'autorité qui l'a signé, et clé publique
2) cle privee = clef du coffre (secret)
role = dechifrer les donnees que les clients ont envoyees en utilisant la clef publique
securite = Si quelqu'un vole ta clé privée, il peut usurper ton identité et lire les messages cryptés destinés à ton serveur

Comment ça marche lors d’une connexion HTTPS ?
1. Le client demande une connexion sécurisée à nginx.
2. Nginx envoie son certificat (contenant la clé publique) au client.
3. Le client vérifie que le certificat est valide (date, signature de l’autorité, correspondance du nom de domaine).
4. Le client crée une clé de session (clé symétrique temporaire) et la chiffre avec la clé publique du serveur (dans le certificat).
5. Le serveur (nginx) déchiffre la clé de session avec sa clé privée.
6. Maintenant, client et serveur ont une clé symétrique partagée pour chiffrer toute la communication rapidement.
7. Toute la communication est sécurisée grâce à cette clé symétrique.

Pourquoi creer un fichier /var/run/nginx ?
Ce dossier sert à stocker ce qu'on appelle un PID file (Process ID).
-Le concept : Quand Nginx se lance, il écrit son numéro d'identité (le PID) dans un petit fichier à cet endroit précis.
Cela permet au système de savoir si Nginx est déjà en train de tourner et de pouvoir l'arrêter proprement.
-Le problème Docker : Dans certaines versions de Debian/Alpine (les images de base que tu utilises pour Docker), ce dossier n'existe pas par défaut ou n'a pas les bonnes permissions.
Si Nginx essaie de se lancer et ne trouve pas ce dossier pour y écrire son PID, il va crash instantanément avec une erreur.
=> il s'agit de modifier les dossiers systeme a l'interieur du conteneur

# Filesystem Hierarcy Standard (FHS); # dossiers:
-  /usr/local/bin = executables installes par l'utilisateur (localise ici ils sont appelable partout)
- /etc = fichiers de configuration statique (c'est ici que les logiciels comme php ou nginx cont chercher leurs reglagles au demarrage)
- /var/www = dossier standard de stockage des donnees variables (ie qui changent pendant l'execution) de serveur web
--/var/lib : données persistantes propres à un service
--/var/www : convetion Lunix pour les fichiers web
- /tmp = dossier destine aux fichiers temporaires (comme les script de config qui servent a configurer des conteneurs au demarrage, avant que le site ne tourne)
- /run = runtime data; contient les données valides uniquement depuis le dernier démarrage. Ce dossier est vidé automatiquement à chaque redémarrage du PC/Conteneur.

# Autres DEFINITIONS UTILES

- code source = texte lisible par l'humain ecrit par les programmeurs

- reverse proxy = serveur ayant pour rôle de recevoir les connexions qui viennent de l'extérieur 

- direct proxy = serveur qui agit au nom d'un client pour aller chercher des ressources sur Internet.
Si j'envoie une requete www.google.fr, mon pc ne l'envoie pas directement a google mais au direct proxy de l'ecole qui l'autorise ou non, l'envoie a google et recupere la reponse et nous l'envoie
Interet : anonymat (l'IP du proxy est affichee), filtrage (ex; bloquer facebook), mise en cache (si 50 pc ont demande le site, le proxy le met en cahce et l'envoie a tout le monde, cela economise de la bande passante)

- systeme d'exploitation (OS) : logiciel principal qui gère un ordinateur (exemples : Linux Debian, Windows, macOS). Il fournit les services de base nécessaires pour que d'autres programmes (les applications) puissent fonctionner.

- noyau (kernel) : c'est le composant central et le cœur du système d'exploitation. C'est le seul programme qui a un accès direct et un contrôle total sur les composants physiques (processeur, mémoire RAM, disque dur, carte réseau).

=> Lorsqu'une application (comme Nginx) a besoin de lire un fichier sur le disque dur, elle ne peut pas le faire elle-même. Elle envoie une requête au noyau. Le noyau reçoit la requête, la valide, ordonne au disque dur physique de lire la donnée, puis renvoie la donnée à l'application.

# VM vs Docker

- virtualiser : créer une version logicielle et abstraite d'une ressource informatique, plutôt que d'utiliser une ressource physique réelle. C'est le fait d'utiliser du code pour simuler l'existence et le comportement d'un composant matériel ou d'un environnement logiciel.

- VM = virtualiser le materiel, il s'agit d'une simulation d'ordinateur vide
le logiciel de virtualisation (l'hyperviseur, comme VirtualBox) crée des ordinateurs simulés de toutes pièces.
L'hyperviseur prend une portion des composants physiques de la machine réelle et crée des composants virtuels isolés. Il génère un processeur virtuel, alloue un bloc de RAM virtuelle et crée un fichier qui agit comme un disque dur virtuel.

- Docker = Virtualiser le système d'exploitation
La virtualisation se produit un niveau plus haut, directement dans le système d'exploitation de la machine hôte.
Un seul noyau divise ses ressources pour isoler des programmes, sans jamais simuler de matériel ni dupliquer le noyau.

# Le passage du logiciel au materiel

1. L'Appel Système (Le logiciel)
Lorsqu'un programme (comme Nginx) a besoin d'un fichier, il exécute une fonction spécifique appelée appel système (par exemple, la fonction read()).
- Cette fonction indique au processeur (CPU) de suspendre l'exécution du programme et de passer en "mode noyau" (Kernel mode).
- Le noyau prend le relais avec des privilèges d'exécution maximum.

2. Le Pilote de Périphérique (Le Driver)
Le noyau ne sait pas comment faire fonctionner physiquement chaque modèle de disque dur existant. Il utilise donc un composant logiciel appelé pilote (driver).
- Le pilote est un code fourni par le fabricant du matériel.
- Le noyau indique au pilote quel bloc de données il veut lire.
- Le pilote convertit cette demande générique en instructions spécifiques basées sur le protocole technique du disque (par exemple, les normes SATA ou NVMe).

3. Le Bus et les Signaux Électriques (La transition physique)

C'est ici que le logiciel devient matériel. Le processeur va écrire ces instructions dans des zones de mémoire spécifiques appelées "registres matériels".
- Le processeur génère des variations de tension électrique (des 0 et des 1).
- Ces impulsions électriques voyagent physiquement à travers des pistes de cuivre intégrées à la carte mère de l'ordinateur. L'ensemble de ces pistes de cuivre s'appelle le Bus (souvent le bus PCIe).

# DNS (Domain Name System ou systeme de nom de domaine) #
C'est un système de traduction indispensable dans un réseau informatique.

- Le problème : Les ordinateurs ne communiquent qu'avec des adresses IP (ex : 192.168.1.15). Mais les humains (et les configurations logicielles) préfèrent utiliser des noms (ex : google.com ou mariadb)

- La solution (DNS) : C'est un annuaire automatique. Quand tu tapes google.com, le serveur DNS cherche dans sa liste et répond à ton ordinateur : "L'adresse IP de https://www.google.com/url?sa=E&source=gmail&q=google.com est 142.250.75.100". Ton ordinateur se connecte alors à cette IP.

Dans Inception, Docker possède son propre DNS interne.



# Code source de Wordpress #

Lors de l'installation de Wordpress, on telecharge un dossier rempli de fichiers textes, ce n'est pas un seul bloc (comme un .exe). C'est une collection de fichiers qui travaillent ensemble.

#HTML (structure, squelette)
Ce n'est pas un langage de programmation, c'est du balisage. Il dit au navigateur "Ceci est un titre", "Ceci est une image".
ex:
      <h1>Bienvenue sur mon site</h1>
      <p>Ceci est un paragraphe de texte.</p>

#CSS (style, habillage)
Ce sont des fichiers (extension .css) qui disent au navigateur comment afficher le HTML. Ex:
  h1 {
      color: red;
      font-size: 20px;
  }

#PHP (la logique, le cerveau)
C'est un programme qui ecrit du html
Ex : <?php
  // 1. LOGIQUE (PHP) : On définit des variables (ou on les cherche dans MariaDB)
  $nom_utilisateur = "Erika";
  $couleur_titre = "blue";
?>

<html>
  <head>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1 style="color: <?php echo $couleur_titre; ?>;">
      Bienvenue <?php echo $nom_utilisateur; ?> !
    </h1>
  </body>
</html>

Quand tu demandes cette page :
Nginx voit l'extension .php. Il ne l'envoie pas au navigateur. Il le passe à PHP-FPM.
PHP-FPM lit le fichier de haut en bas.
Il exécute les instructions entre <?php ... ?>.
Il remplace <?php echo $nom_utilisateur; ?> par "Erika".
Il remplace <?php echo $couleur_titre; ?> par "blue".
Il supprime toutes les balises PHP du résultat final.
Code source reçu (HTML) :
<html>
  <head>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1 style="color: blue;">
      Bienvenue Erika !
    </h1>
  </body>
</html>


Particularite du PHP : Contrairement au C++ que tu dois compiler (transformer en a.out illisible) pour qu'il fonctionne, le PHP est un langage interprété. Cela signifie que le "code source" (les fichiers textes) EST le programme final.
- Langage COMPILE = Le compilateur traduit tout le code d'un coup en langage machine (des 0 et des 1), c'est la compilation, et on oibtient un fichier binaire executable. Avantage = rapidite; inconvenient = recompilation necessaire pour une seul ligne changee
VS
- langage INTERPRETE = Ecriture en code comprehensible puis execution : Quand tu lances le programme, un logiciel appelé l'interpréteur (ex: le programme python ou php-fpm) lit ton fichier ligne par ligne. Le code source EST le programme. Avantage : Flexible. Tu modifies le fichier texte, tu sauvegardes, et la modification est immédiate (pas de make re); Inconvénient : Plus lent

ce que le volume Wordpress peut contenir uniquement :
- themes (ficheir a trou) -> apparence du site
- plugins -> fonctions supplementaires
- medias uplaodes

WordPress repose à 100% sur une base MySQL/MariaDB pour :
- articles, pages (bd wp_posts)
- utilisateurs (bd wp_users)
- reglages du site (bd wp_options)
- menus
- contenu des plugins

# Pourquoi a-t-on besoin de plusieurs processus pour faire tourner wordpress ? #
Parce qu'un processus PHP-FPM (appelé "Worker" ou travailleur) ne peut traiter qu'une seule requête HTTP à la fois
Dans l'architecture de PHP-FPM, il y a deux types de processus :
- Le processus Maître (Master Process) : Il ne traite jamais les requêtes web. Son unique travail est de surveiller le réseau et de gérer la RAM.
- Les processus Enfants (Child Processes / Workers) : ils exécutent le code WordPress.


# Fonctionnement de Socket Unix #
Il s'agit d'un mécanisme de communication inter-processus (IPC) géré par le noyau Linux.
Elle permet à deux programmes s'exécutant sur la même machine d'échanger des données
- Dans le système de fichiers, elle se présente sous la forme d'un fichier avec une extension .sock.
- Contrairement à un fichier texte standard, aucune donnée n'est écrite sur le disque dur physique.
Lorsque Nginx tente "d'écrire" dans ce fichier .sock :
1) Le processus de destination (PHP-FPM) demande au noyau Linux dede créer l'entrée /run/php/php8.2-fpm.sock dans le système de fichiers, en spécifiant que cette entrée est une socket liée à son propre processus.
2) Nginx veut envoyer une requête web. Il demande au noyau Linux d'ouvrir le fichier /run/php/php8.2-fpm.sock pour y écrire des données.
3) L'interception : Le noyau Linux voit que le type de ce fichier est une socket. Au lieu de transmettre les données au disque dur, le noyau intercepte les données.
4) Le transfert en RAM : Le noyau Linux prend les données depuis la mémoire vive (RAM) allouée à Nginx, et les injecte directement dans la mémoire vive (RAM) allouée à PHP-FPM



# Les differents mode de reseaux #

1) Mode bridge (par defaut dans Docker)
Chaque conteneur reçoit une adresse IP privée dans un sous-réseau spécifique
Les conteneurs sont isolés du réseau physique de la VM. Pour qu'un service soit accessible depuis l'extérieur de la VM (ou depuis la VM elle-même), il faut effectuer un mappage de ports (ex: -p 80:80).
Communication :
- Bridge par défaut : Les conteneurs communiquent via leurs adresses IP uniquement.
- User-defined Bridge (celui d'Inception) : Docker active un résolveur DNS interne. Cela permet à wordpress de contacter mariadb en utilisant le nom du service, sans connaître son IP.

2) Mode host
Ce mode supprime l'isolation réseau entre le conteneur et la VM
Le conteneur n'a pas sa propre adresse IP. Il utilise directement l'adresse IP de la VM.
Pas de translation de port (NAT)
Rapide car pas de surcharge lie a la virtualisation reseau mais moins securise et flexible

3) Mode None
= Aucune connectivité réseau du conteneur.
Le conteneur possède une interface de boucle locale (lo / 127.0.0.1), mais aucune interface réseau externe (pas de eth0).
Utile pour des conteneurs qui effectuent des calculs isolés ou des tâches de traitement de fichiers ne nécessitant aucun accès réseau (sécurité maximale).

4) Mode Overlay
Ce mode est utilisé pour la communication entre conteneurs situés sur des hôtes (VM) différents.
Il crée un réseau virtuel au-dessus des réseaux des hôtes physiques.

5) Le mode Macvlan
Ce mode permet de donner une adresse MAC directement au conteneur.
Le conteneur apparaît comme un équipement physique réel sur le réseau local de la box ou du routeur, comme la VM elle-même.
Usage : Très spécifique, utilisé quand des applications héritées (legacy) ont besoin d'être connectées directement au réseau physique sans passer par le NAT de Docker.
