
# Demande au processus Maître de Nginx (qui démarre avec les droits root)
# de lancer tous ses processus de travail (les processus qui gèrent les requêtes des visiteurs)
# sous l'identité de l'utilisateur Linux www-data
user www-data;

# Définit le nombre de processus de travail (Workers) que Nginx va exécuter simultanément
# Un seul processus de travail Nginx est capable de maintenir des dizaines de milliers de connexions réseau (sockets TCP) ouvertes en même temps.
# Un cœur de processeur ne peut exécuter qu'un seul processus à la fois. Par conséquent, un processus de travail Nginx est physiquement limité par la fréquence d'horloge (les GHz) du cœur CPU sur lequel il s'exécute.
# avec la directive auto, nginx nterroge le noyau Linux pour obtenir le compte exact des cœurs logiques disponibles
# Si le noyau répond "4", Nginx lance exactement 4 processus de travail distincts dans la mémoire vive.
# L'ordonnanceur du noyau Linux répartit alors nativement ces 4 processus sur les 4 cœurs physiques du processeur.
worker_processes auto;

# Indique le chemin ou le processus maitre de Nginx doit erire son numero de'identification
pid /run/nginx.pid;

# Définit l'emplacement du fichier texte où Nginx inscrira toutes ses erreurs internes (erreur de syntaxe dans la conf, refus d'acces a un fichier etc)
# Il diffère du journal des accès (access_log) qui enregistre l'historique des requêtes HTTP réussies des visiteurs
error_log /var/log/nginx/error.log;

# Demande à Nginx de lire tous les fichiers possédant l'extension .conf situés dans le dossier spécifié, et d'insérer virtuellement leur contenu exactement à cette ligne avant de continuer le chargement.
include /etc/nginx/modules-enabled/*.conf;

events {
    #definit le nombre de connexions max
	worker_connections 768;

    #permet d'accepter plusieurs connexions a la fois
    multi_accept on;
}

http {
	# inclut fichier contenant un tableau de correspondance entre les extension et le type des fichiers
    include /etc/nginx/mime.types;

	# 1. Le bloc poubelle (Catch-all)
	# si la requete n'est pas a destinationd de ele-borg.42.fr, nginx renvoie 444
	server {
	    listen 443 ssl default_server;
	    server_name _; # Le tiret bas capture tous les noms de domaine non reconnus

	    ssl_certificate /etc/nginx/ssl/inception.crt;
	    ssl_certificate_key /etc/nginx/ssl/inception.key;

	    return 444; # Ferme la connexion TCP immédiatement
	}

	# 2. mon serveur
    server {
        #TLS Configuration
        listen 443 ssl; #permet au conteneur NGINX d'ecouter sur le port TCP 443 de sa propre carte reseau
		ssl_protocols TLSv1.2 TLSv1.3; # restreint l'établissement de la connexion chiffrée aux versions modernes du protocole.
		ssl_certificate /etc/nginx/ssl/inception.crt; #indique au processu maitre la localisation de la cle publique a envoyer au client
		ssl_certificate_key /etc/nginx/ssl/inception.key; # localisation de la cle privee pour dechiffrer les requetes entrantes

        root /var/www/wordpress;

		# Spécifie l'ordre de recherche des fichiers si l'utilisateur demande un dossier. Nginx cherchera d'abord index.php. S'il n'existe pas, il cherchera index.html
        index index.php index.html index.htm;

		# Le processus Nginx lit l'en-tête HTTP Host de la requête entrante. Si cet en-tête correspond exactement à ele-borg.42.fr, Nginx traite la requête en utilisant les règles de ce bloc server.
        server_name $DOMAIN_NAME;
		# server_name ele-borg.42.fr;

		# try_files : Exécute une série de tests sur le système de fichiers.
		# $uri : Nginx vérifie si l'URI correspond à un fichier exact (ex: logo.png).
		# $uri/ : Nginx vérifie si l'URI correspond à un dossier exact.
		# =404 : Si les deux tests échouent, le processus s'arrête et renvoie un code HTTP 404 (Not Found) au client.
        location / {
            try_files $uri $uri/ =404;
        }

		#~ \.php$ : Expression régulière demandant à Nginx d'intercepter uniquement les URI se terminant par .php
        location ~ \.php$ {
            include snippets/fastcgi-php.conf; # Charge les paramètres d'environnement standards de FastCGI requis pour le fonctionnement de PHP
            fastcgi_pass wordpress:9000; # Nginx stoppe le traitement du fichier en interne, initie une connexion TCP réseau vers l'hôte wordpress sur le port 9000, et transmet les données de la requête
        }
    }

	# Modifie la façon dont le noyau Linux transfère les fichiers statiques (images, CSS). 
	# Au lieu de copier le fichier du disque dur vers la mémoire utilisateur de Nginx, 
	# puis vers la carte réseau (2 étapes), 
	# cette directive ordonne au noyau d'effectuer le transfert directement du disque dur vers la mémoire de la carte réseau (Zero-Copy)
	sendfile on;
	# demande au noyau Linux de stocker les paquets réseau en mémoire tampon jusqu'à ce qu'ils atteignent la taille maximale autorisée (MSS), puis de les envoyer en un seul bloc
	tcp_nopush on;

	# Quand Nginx répond à une requête HTTP, il doit obligatoirement inclure un en-tête (Header) appelé Content-Type
	# Lire un fichier texte de configuration contenant cette correspondance sur le disque dur à chaque requête web est trop lent pour le processeur
	# cette ligne permet a nginx de charger cette liste des extensions en memoire vive (RAM) au demarrage, dans une structure appelee table de hachage
	types_hash_max_size 2048;

	# Si un visiteur demande un fichier avec une extension inconnue de Nginx, 
	# il enverra dans sa reponse un content-type valant application/octet-stream
	# terme technique standard pour désigner un "flux d'octets binaires inconnu"
	# le comportement du navigateur codé en dur est de ne pas essayer d'afficher le contenu à l'écran,
	# mais d'ouvrir une fenêtre "Enregistrer sous..." pour télécharger le fichier.
	default_type application/octet-stream;

	# lors du handshake lors de l'établissement d'une connexion HTTPS
	# le navigateur du visiteur envoie à Nginx une liste des algorithmes mathématiques de chiffrement qu'il supporte.
	# cette directive force Nginx à ignorer la préférence du navigateur et à imposer sa propre liste d'algorithmes (définie côté serveur)
	# => mesure de sécurité stricte. 
	# Elle empêche une attaque par rétrogradation (Downgrade Attack), où un client malveillant tenterait de forcer Nginx à utiliser un algorithme obsolète ou vulnérable pour faciliter le déchiffrement du trafic réseau.
	ssl_prefer_server_ciphers on;

	# Nginx ouvre ce fichier texte et y inscrit une nouvelle ligne de données pour chaque requête HTTP entrante traitée.
	access_log /var/log/nginx/access.log;

	#Optimisation de la bande passante : les fichiers envoye par TCP sont compresse par NGINX
	gzip on;

	#Ordonne au processus de lecture de Nginx d'importer le contenu de tous les fichiers présents dans ces dossiers spécifiques 
	# ces autres fichiers continennent d'autres regles de parametrage
	include /etc/nginx/conf.d/*.conf;
	#include /etc/nginx/sites-enabled/*;
}



