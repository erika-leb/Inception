
# Demande au processus Maître de Nginx (qui démarre avec les droits root)
# de lancer tous ses processus de travail (les processus qui gèrent les requêtes des visiteurs)
# sous l'identité de l'utilisateur Linux www-data
user www-data;

# Définit le nombre de processus de travail (Workers) que Nginx va exécuter simultanément
# Un seul processus de travail Nginx est capable de maintenir des dizaines de milliers de connexions réseau (sockets TCP) ouvertes en même temps.
# Un cœur de processeur ne peut exécuter qu'un seul processus à la fois. Par conséquent, un processus de travail Nginx est physiquement limité par la fréquence d'horloge (les GHz) du cœur CPU sur lequel il s'exécute.
# avec la directive auto, nginx nterroge le noyau Linux pour obtenir le compte exact des cœurs logiques disponibles
# Si le noyau répond "4", Nginx lance exactement 4 processus de travail distincts dans la mémoire vive.
# L'ordonnanceur du noyau Linux répartit alors nativement ces 4 processus sur les 4 cœurs physiques du processeur.
worker_processes auto;

# Indique le chemin ou le processus maitre de Nginx doit erire son numero de'identification
pid /run/nginx.pid;

# Définit l'emplacement du fichier texte où Nginx inscrira toutes ses erreurs internes (erreur de syntaxe dans la conf, refus d'acces a un fichier etc)
# Il diffère du journal des accès (access_log) qui enregistre l'historique des requêtes HTTP réussies des visiteurs
error_log /var/log/nginx/error.log;

# Demande à Nginx de lire tous les fichiers possédant l'extension .conf situés dans le dossier spécifié, et d'insérer virtuellement leur contenu exactement à cette ligne avant de continuer le chargement.
include /etc/nginx/modules-enabled/*.conf;

events {
    #definit le nombre de connexions max
	worker_connections 768;

    #permet d'accepter plusieurs connexions a la fois
    multi_accept on;
}

http {
	# inclut fichier contenant un tableau de correspondance entre les extension et le type des fichiers
    include /etc/nginx/mime.types;

    server {
        #TLS Configuration
        listen 443 ssl; #permet au conteneur NGINX d'ecouter sur le port TCP 443 de sa propre carte reseau
		ssl_protocols TLSv1.2 TLSv1.3; @# restreint l'établissement de la connexion chiffrée aux versions modernes du protocole.
		ssl_certificate /etc/nginx/ssl/inception.crt; #indique au processu maitre la localisation de la cle publique a envoyer au client
		ssl_certificate_key /etc/nginx/ssl/inception.key; # localisation de la cle privee pour dechiffrer les requetes entrantes

        root /var/www/wordpress;

		# Spécifie l'ordre de recherche des fichiers si l'utilisateur demande un dossier. Nginx cherchera d'abord index.php. S'il n'existe pas, il cherchera index.html
        index index.php index.html index.htm;

		# Le processus Nginx lit l'en-tête HTTP Host de la requête entrante. Si cet en-tête correspond exactement à ele-borg.42.fr, Nginx traite la requête en utilisant les règles de ce bloc server.
        server_name ele-borg.42.fr;

		# try_files : Exécute une série de tests sur le système de fichiers.
		# $uri : Nginx vérifie si l'URI correspond à un fichier exact (ex: logo.png).
		# $uri/ : Nginx vérifie si l'URI correspond à un dossier exact.
		# =404 : Si les deux tests échouent, le processus s'arrête et renvoie un code HTTP 404 (Not Found) au client.
        location / {
            try_files $uri $uri/ =404;
        }

		#~ \.php$ : Expression régulière demandant à Nginx d'intercepter uniquement les URI se terminant par .php
        location ~ \.php$ {
            include snippets/fastcgi-php.conf; # Charge les paramètres d'environnement standards de FastCGI requis pour le fonctionnement de PHP
            fastcgi_pass wordpress:9000; # Nginx stoppe le traitement du fichier en interne, initie une connexion TCP réseau vers l'hôte wordpress sur le port 9000, et transmet les données de la requête
        }
    }

	# Modifie la façon dont le noyau Linux transfère les fichiers statiques (images, CSS). Au lieu de copier le fichier du disque dur vers la mémoire utilisateur de Nginx, puis vers la carte réseau (2 étapes), cette directive ordonne au noyau d'effectuer le transfert directement du disque dur vers la mémoire de la carte réseau (Zero-Copy)
	sendfile on;
	# demande au noyau Linux de stocker les paquets réseau en mémoire tampon jusqu'à ce qu'ils atteignent la taille maximale autorisée (MSS), puis de les envoyer en un seul bloc
	tcp_nopush on;
	types_hash_max_size 2048;

	default_type application/octet-stream;

	ssl_prefer_server_ciphers on;

	# Nginx ouvre ce fichier texte et y inscrit une nouvelle ligne de données pour chaque requête HTTP entrante traitée.
	access_log /var/log/nginx/access.log;

	#Optimisation de la bande passante : les fichiers envoye par TCP osnt compresse par NGINX
	gzip on;

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}



